<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Roll Dice Customiz√°vel</title>

<!-- Tailwind para estilo r√°pido -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- THREE.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/examples/js/loaders/GLTFLoader.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/examples/js/controls/OrbitControls.min.js"></script>

<style>
  :root {
    --accent: #38bdf8;
    --bg: #0f172a;
    --text: #f1f5f9;
    --neon-shadow: 0 0 8px var(--accent), 0 0 16px var(--accent);
  }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: system-ui, sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }
  #canvasWrapper {
    flex: 1;
    background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
  }
  .neon {
    color: var(--accent);
    text-shadow: var(--neon-shadow);
  }
  #resultBox {
    font-size: 5rem;
    color: var(--accent);
    text-shadow: var(--neon-shadow);
    margin-top: 1rem;
    text-align: center;
    font-family: var(--custom-font, system-ui);
  }
</style>
</head>
<body>
  <header class="p-4 text-center text-2xl font-bold neon">Roll Dice Customiz√°vel</header>
  
  <main class="flex flex-col lg:flex-row gap-4 p-4 flex-grow">
    <section id="canvasWrapper" class="flex-1 rounded-xl shadow-lg overflow-hidden">
      <canvas id="scene" class="w-full h-full"></canvas>
    </section>

    <section class="w-full lg:w-72 bg-slate-800/60 backdrop-blur-sm rounded-xl p-4 space-y-4 shadow-lg flex flex-col">
      <h2 class="text-xl font-semibold mb-2">üéõÔ∏è Configurar Rolagem</h2>
      
      <label class="block mb-1">Carregar fonte (.ttf ou .woff2)</label>
      <input type="file" id="fontInput" accept=".ttf,.woff2" class="mb-4" />

      <label class="block mb-1">Carregar modelo 3D (.glb)</label>
      <input type="file" id="modelInput" accept=".glb" class="mb-4" />

      <label class="block mb-2">Tipo de dado</label>
      <select id="dieType" class="w-full p-2 rounded bg-slate-700 text-white">
        <option value="4">d4</option>
        <option value="6" selected>d6</option>
        <option value="8">d8</option>
        <option value="10">d10</option>
        <option value="12">d12</option>
        <option value="20">d20</option>
      </select>

      <label class="block mt-4 mb-2">Quantidade</label>
      <input id="dieQty" type="number" min="1" max="10" value="1" class="w-full p-2 rounded bg-slate-700 text-white" />

      <label class="block mt-4 mb-2">Modificador (+ / ‚Äì)</label>
      <input id="modifier" type="number" value="0" class="w-full p-2 rounded bg-slate-700 text-white" />

      <div class="flex gap-2 mt-6">
        <button id="addBtn" class="flex-1 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-2 rounded" disabled>Adicionar</button>
        <button id="rollBtn" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 rounded" disabled>Rolar üé≤</button>
      </div>

      <h3 class="text-lg font-medium mt-6">Pool atual</h3>
      <ul id="pool" class="text-sm space-y-1"></ul>

      <div id="resultBox" class="font-bold neon"></div>
    </section>
  </main>

  <footer class="p-4 text-center text-xs text-slate-400">
    Feito com ‚ù§ usando THREE.js ‚Ä¢ Totalmente customiz√°vel
  </footer>

<script>
  let d20Mesh = null;
  let currentFontName = null;
  let dicePool = [];

  // THREE.js Setup
  const canvas = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
  camera.position.set(0, 2, 4);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
  dirLight.position.set(3, 5, 2);
  scene.add(dirLight);

  function resize() {
    const { clientWidth, clientHeight } = canvas.parentElement;
    renderer.setSize(clientWidth, clientHeight, false);
    camera.aspect = clientWidth / clientHeight;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize);
  resize();

  function geometryForFaces(faces) {
    if(faces === 20 && d20Mesh) return d20Mesh.clone();
    switch(faces) {
      case 4: return new THREE.TetrahedronGeometry(1);
      case 6: return new THREE.BoxGeometry(1,1,1);
      case 8: return new THREE.OctahedronGeometry(1);
      case 10: return new THREE.OctahedronGeometry(1);
      case 12: return new THREE.DodecahedronGeometry(1);
      default: return new THREE.BoxGeometry(1,1,1);
    }
  }

  function materialForDie() {
    return new THREE.MeshStandardMaterial({ color: 0x38bdf8, metalness: 0.3, roughness: 0.4 });
  }

  class Die {
    constructor(faces) {
      this.faces = faces;
      this.value = randInt(faces);
      this.geometry = geometryForFaces(faces);
      this.material = materialForDie();
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      scene.add(this.mesh);
    }
    roll() {
      this.value = randInt(this.faces);
      this.targetRotation = new THREE.Euler(
        Math.random() * Math.PI * 4,
        Math.random() * Math.PI * 4,
        Math.random() * Math.PI * 4
      );
      this.startRotation = this.mesh.rotation.clone();
      this.startTime = performance.now();
    }
    update() {
      if (!this.targetRotation) return;
      const now = performance.now();
      const t = Math.min((now - this.startTime) / 800, 1);
      this.mesh.rotation.x = THREE.MathUtils.lerp(this.startRotation.x, this.targetRotation.x, t);
      this.mesh.rotation.y = THREE.MathUtils.lerp(this.startRotation.y, this.targetRotation.y, t);
      this.mesh.rotation.z = THREE.MathUtils.lerp(this.startRotation.z, this.targetRotation.z, t);
      if (t === 1) this.targetRotation = null;
    }
    dispose() {
      scene.remove(this.mesh);
      if(this.geometry.dispose) this.geometry.dispose();
      if(this.material.dispose) this.material.dispose();
    }
  }

  function randInt(max) {
    return Math.floor(Math.random() * max) + 1;
  }

  function refreshPoolList() {
    const poolUL = document.getElementById('pool');
    poolUL.innerHTML = dicePool.map((d,i) => 
      `<li class="flex justify-between">
        <span>${i+1}) d${d.faces}</span>
        <button data-idx="${i}" class="text-red-400">√ó</button>
      </li>`).join('');
    poolUL.querySelectorAll('button').forEach(btn => {
      btn.onclick = () => {
        const idx = +btn.dataset.idx;
        dicePool[idx].dispose();
        dicePool.splice(idx, 1);
        refreshPoolList();
      };
    });
  }

  function loadFont(file) {
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      const fontDataUrl = e.target.result;
      const oldStyle = document.getElementById('dynamicFontStyle');
      if(oldStyle) oldStyle.remove();
      const fontName = file.name.split('.').slice(0,-1).join('_').replace(/\s+/g,'_');
      currentFontName = fontName;
      const style = document.createElement('style');
      style.id = 'dynamicFontStyle';
      style.textContent = `
        @font-face {
          font-family: '${fontName}';
          src: url('${fontDataUrl}');
          font-weight: normal;
          font-style: normal;
        }
      `;
      document.head.appendChild(style);
      document.documentElement.style.setProperty('--custom-font', `'${fontName}', system-ui`);
    };
    reader.readAsDataURL(file);
  }

  function loadModel(file) {
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      const arrayBuffer = e.target.result;
      const loader = new THREE.GLTFLoader();
      loader.parse(arrayBuffer, '', (gltf) => {
        d20Mesh = gltf.scene;
        enableButtons();
      }, (err) => {
        alert('Erro ao carregar modelo 3D');
        console.error(err);
      });
    };
    reader.readAsArrayBuffer(file);
  }

  function enableButtons() {
    document.getElementById('addBtn').disabled = false;
    document.getElementById('rollBtn').disabled = false;
  }

  document.getElementById('fontInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    loadFont(file);
  });
  document.getElementById('modelInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    loadModel(file);
  });

  document.getElementById('addBtn').onclick = () => {
    const faces = +document.getElementById('dieType').value;
    const qty = +document.getElementById('dieQty').value;
    for(let i=0; i<qty; i++) {
      const die = new Die(faces);
      die.mesh.position.set((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2);
      dicePool.push(die);
    }
    refreshPoolList();
  };

  document.getElementById('rollBtn').onclick = () => {
    if(dicePool.length === 0) {
      alert('Adicione pelo menos um dado!');
      return;
    }
    dicePool.forEach(d => d.roll());
    const mod = +document.getElementById('modifier').value;
    setTimeout(() => {
      const total = dicePool.reduce((sum, d) => sum + d.value, 0) + mod;
      const modStr = mod ? (mod > 0 ? ` + ${mod}` : ` ‚àí ${Math.abs(mod)}`) : '';
      document.getElementById('resultBox').textContent = `${total} (Œ£ ${dicePool.map(d => d.value).join(' + ')}${modStr})`;
    }, 850);
  };

  function animate() {
    requestAnimationFrame(animate);
    dicePool.forEach(d => d.update());
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
